"use strict";
/**
 * MIT License
 *
 * Copyright (c) 2019 Kasun Vithanage
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.P24 = void 0;
const axios_1 = __importDefault(require("axios"));
const errors_1 = require("../errors");
const ips_1 = require("./ips");
const hash_1 = require("../utils/hash");
const endpoints_1 = require("./endpoints");
/**
 * Represents a P24 payment system
 *
 * @export
 * @class P24
 */
class P24 {
    /**
    * Creates an instance of Przelewy24.
    * @param {number} merchantId Merchant ID given by Przelewy24
    * @param {number} posId Shop ID (defaults to merchantId)
    * @param {string} apiKey API Key from P24 panel(Klucz do raport√≥w)
    * @param {string} crcKey CRC key from P24 panel
    * @param {P24Options} [options={ sandbox: false }] - additional options
    * @memberof P24
    */
    constructor(merchantId, posId, apiKey, crcKey, options = { sandbox: false }) {
        this.merchantId = merchantId;
        this.posId = posId;
        this.crcKey = crcKey;
        this.apiKey = apiKey;
        this.options = options;
        if (!this.posId)
            this.posId = this.merchantId;
        this.baseUrl = !this.options.sandbox ? endpoints_1.ProductionUrl : endpoints_1.SandboxUrl;
        this.baseParameters = {
            merchantId: this.merchantId,
            posId: this.posId
        };
        this.client = axios_1.default.create({
            baseURL: `${this.baseUrl}/api/v1`,
            auth: {
                username: posId.toString(),
                password: this.apiKey
            }
        });
    }
    /**
     * Test access to the service
     *
     * @returns {Promise<boolean>}
     * @throws {P24Error}
     * @memberof P24
     */
    testAccess() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.client.get(endpoints_1.EndpointTestAccess);
                const res = data;
                return res.data === true;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.P24Error(resp.error, resp.code);
                }
                throw new errors_1.P24Error(`Unknown Error ${error}`, -1);
            }
        });
    }
    /**
     * Creates a transaction
     *
     * @param {Order} order - order to be created
     * @returns {Promise<Transaction>}
     * @throws {P24Error}
     * @memberof P24
     */
    createTransaction(order) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const hashData = {
                    sessionId: order.sessionId,
                    merchantId: this.merchantId,
                    amount: order.amount,
                    currency: order.currency,
                    crc: this.crcKey
                };
                const sign = hash_1.calculateSHA384(JSON.stringify(hashData));
                const orderData = Object.assign(Object.assign(Object.assign({}, this.baseParameters), order), { sign });
                const { data } = yield this.client.post(endpoints_1.EndpointTransactionRegister, orderData);
                const response = data;
                const transaction = {
                    token: response.data.token,
                    link: `${this.baseUrl}${endpoints_1.EndpointTransactionRequest}/${response.data.token}`
                };
                return transaction;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.P24Error(resp.error, resp.code);
                }
                throw new errors_1.P24Error(`Unknown Error ${error}`, -1);
            }
        });
    }
    /**
     * Verify transaction
     *
     * @param {Verification} verification - verification request
     * @returns {Promise<boolean>}
     * @throws {P24Error}
     * @memberof P24
     */
    verifyTransaction(verification) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const hashData = {
                    sessionId: verification.sessionId,
                    orderId: verification.orderId,
                    amount: verification.amount,
                    currency: verification.currency,
                    crc: this.crcKey
                };
                const sign = hash_1.calculateSHA384(JSON.stringify(hashData));
                const verificationData = Object.assign(Object.assign(Object.assign({}, this.baseParameters), verification), { sign });
                const { data } = yield this.client.put(endpoints_1.EndpointTransactionVerify, verificationData);
                const result = data;
                return result.data.status === 'success';
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.P24Error(resp.error, resp.code);
                }
                throw new errors_1.P24Error(`Unknown Error ${error}`, -1);
            }
        });
    }
    /**
     * Verify notification transaction with our CRC Key
     *
     * @param {NotificationRequest} notificationRequest
     * @returns {boolean}
     * @memberof P24
     */
    verifyNotification(notificationRequest) {
        const notificationHash = Object.assign(Object.assign({}, notificationRequest), { sign: undefined, crc: this.crcKey });
        const sign = hash_1.calculateSHA384(JSON.stringify(notificationHash));
        return sign === notificationRequest.sign;
    }
    /**
     * Handle refund
     *
     * @param {RefundRequest} refundRequest
     * @returns {Promise<RefundResult[]>}
     * @memberof P24
     */
    refund(refundRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.client.post(endpoints_1.EndpointRefund, refundRequest);
                const resp = data;
                return resp.data;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    if (error.response.data.code === 409) {
                        const resp = error.response.data;
                        throw new errors_1.P24Error('Refund Conflict', resp.code, resp.error);
                    }
                    const resp = error.response.data;
                    throw new errors_1.P24Error(resp.error, resp.code);
                }
                throw new errors_1.P24Error(`Unknown Error ${error}`, -1);
            }
        });
    }
    /**
     * Validates IP with P24 backends
     *
     * @static
     * @param {string} ip - IP Address
     * @returns {boolean} - true on validated ip
     * @memberof Przelewy24
     */
    static isIpValid(ip) {
        return ips_1.validIps.includes(ip);
    }
}
exports.P24 = P24;
//# sourceMappingURL=P24.js.map